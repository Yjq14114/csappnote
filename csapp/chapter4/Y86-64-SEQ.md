

# 4.1.1程序员的可见状态

设计一个Y86-64处理器用来理解x86-64处理器

程序中的每条指令都会读取或修改处理器状态的某些部分。

Y86-64状态类 15种状态类

| %rax | %rsp | %r8  | %r12 |
| ---- | ---- | ---- | ---- |
| %rcx | %rbp | %r9  | %13  |
| %rdx | %rsi | %r10 | %14  |
| %rbx | %rdi | %r11 |      |



# 4.3.1 将处理组织成阶段

- 取指 fetch 

  从内存中读取指令字节， 地址为程序计数器的值。从指令中抽取出指令指示符字节的两个四位部分称为icode和ifun;  它可能取出一个寄存器指示符字节，指明一个或者两个寄存器操作数指示符rA和rB。它还可能取出一个四字节常数字valC。它按顺序方式计算当前指令的下一条指令的地址valP。也就是说，valP 等于PC 的值加上以取出指令的长度。

- 译码 decode

  译码阶段从寄存器文件读入最多两个操作数，得到值valA and/or valB，通常它读入指令rA和rB字段指明的寄存器，不过有些指令是读寄存器%rsp的。

- 执行 execute 

  在执行阶段，算术/逻辑单元（ALU）要么执行指令指明的操作（根据ifun的值），计算内存引用的有效地址，要么增加或减少栈指针。得到的值我们称为valE。在此，也可能设置条件码。对一条条件传送指令来说，这个阶段会检验条件码和传送条件（由ifun给出），如果条件成立，则更新目标寄存器。同样，对一条跳转指令来说，这个阶段会决定是不是应该选择分支

- 访存 memory

  访存阶段可以将数据写入内存，或者从内存读取数据。读出的值为valM。

- 写回 write back

  写回阶段最多可以写两个结果到寄存器文件

- 更新PC PC update

  将PC设置成下一条指令的地址

分配操作符 <– : 从上至下的顺序求值。

OPq(整数和逻辑运算)

rrmovq(寄存器-寄存器传送)

irmovq(立即数-寄存器传送)

符号
$$
M1[x]
$$
表示访问（读或者写）内存位置x处的一个字节，M8[x] 表示访问8个字节